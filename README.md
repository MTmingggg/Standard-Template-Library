# Standard-Template-Library
STL标准模板库。包括8个常用容器的使用范例及其他要点。
# 01-string字符串容器
1.string是类，char*是指针。string是个char**型的容器。<br>
2.string封装了很多成员方法，包括增删改查等。<br>
3.无需考虑内存释放和越界。靠string类自己维护。
# 02-Vector动态数组/可变数组（单口容器）
1.push_back()尾部添加、pop_back()尾部删除（数组为连续内存，其他元素不需要移动位置）。<br>
2.提供两个迭代器v.begin()（指向第一个元素）和v.end()（指向最后一个的下一个元素）及两个反向迭代器v.rbegin()（指向最后一个元素）和v.rend()（指向第一个元素的上一个元素）。<br>
3.insert()在***指定位置***插入元素，但并未提供***指定位置***的push和pop——尽量在尾部操作，不然影响容器效率。<br>
4.动态增长基本原理：当插入新元素时，如果空间不足，那么vector会重新申请更大的内存空间，然后将原空间数据拷贝到新空间，释放掉旧空间的数据，再把新元素插入新申请空间。<br>
5.swap交换容器原理：非拷贝！而是把本来指向各自堆上第一个元素内容的Ptr指针，***断开并指向对方***。
# 03-Deque双口数组容器
1.deque和vector的区别：deque因为是双口容器，所以比vector多两个方法：头部插入push_front()和头部删除pop_front()，同时相应多两个指针front()和back()。<br>
2.deque的特性：双端插入和删除元素的效率更高、可随机存取效率更高、指定位置插入会导致元素移动位置降低效率。<br>
3.需要***中控器***保存每个空间地址，不需要自己关注释放空间。
# 04-Stack栈
1.stack仅提供了入栈push()、出栈pop()、返回栈顶top()基本方法。<br>
2.栈的特性：无法遍历！不提供迭代器！不支持随机存取访问！访问唯一方式：top()。
# 05-Queue队列
1.Queue仅提供入队push()和出队pop()基本方法，back()队尾和front()队头。<br>
2.一端插入，另一端删除。无法遍历！不提供迭代器！不支持随机访问！（与stack有相同特性）
# 06-List双向链表
1.链表内存是非连续的。好处：添加删除元素时间复杂度都是常数项，不需要移动其他元素，效率比数组高。<br>
2.链表只有在需要时才分配内存。<br>
3.数组不需要额外内存保存地址。链表需要***额外空间开销***保存地址！<br>
4.不支持随机访问！<br>
5.链表拿到第一个节点，相当于拿到整个链表。<br>
***注意！list自己提供的独立sort()成员方法！因为list不支持随机存取访问。而<algorithm>中的sort算法均为可随机访问的容器进行排序，可提高排序效率。**
# 07-Set/Multiset集合容器
1.基于红黑树实现，因此最大的特性为根据值进行自动排序。（所以在插入时就必须要保证能排序，如果插入对象，就要加入排序规则！）<br>
2.只提供insert()方法，没有push和pop。<br>
3.提供迭代器，但不允许通过迭代器改变值，保证位置不会乱。<br>
4.set和multiset的唯一区别：set不允许放重复的元素，multiset允许。
# 08-Map/Multimap键值对容器
1.map和set的区别：map具有键值和实值，所有元素根据键值key自动排序（关注key的数据类型），每次插入的都是一个pair对组，pair.first()为键值，pair.second()为实值，底层实现也是基于红黑树。<br>
2.map的key不能重复，multimap的key可以重复。map同样不允许修改键值，唯一方法是删了再加进去。允许修改实值。<br>
3.map四种插入方式的区别：前三种insert方法实际上返回了一个pair，pair的二参为bool代表是否插入成功，用这个判断第四种类似数组方法默认会覆盖前面重复key的value当访问一个不存在的节点时，第四种会默认创建并为key的value赋默认值0。
# 其他要点
容器共性机制与使用场景、深浅拷贝元素、函数对象与谓词、函数对象适配器（包含***绑定、取反***、仿函数、成员函数）等。
# IDE
Microsoft Visual Studio 2015

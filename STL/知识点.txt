1.容器
容器可以嵌套容器。
分为序列式容器、关联式容器。
序列式容器：元素位置是由进入容器的时机和地点来决定。
关联式容器：元素位置与进入时机和地点无关，进入前容器已经定好位置规则，例如高矮个，进来直接入座。
2.迭代器
可以理解为指针，对指针的操作基本都可以对迭代器操作。迭代器是个类，这个类封装了一个指针。
3.算法
通过有限步骤，解决问题。写的每个函数或多或少解决函数问题。STL提供算法
4.STL为什么会有算法、容器、迭代器？
STL独立分工协作。写容器的提供迭代器，写算法的用迭代器。

序列式容器：
String字符串容器
Vector单口数组——Deque双口数组
Queue队列——Stack栈
List双向链表

关联式容器：底层实现基于红黑平衡二叉树
set/multiset集合容器——map/multimap键值对容器

容器的共性机制：
插入操作时，元素都是拷贝进容器的，而不是引用
提供的元素必须能够被拷贝
除了queue与stack外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。
通常STL不会丢出异常。要求使用者确保传入正确的参数。
每个容器都提供了一个默认构造函数跟一个默认拷贝构造函数。
与大小相关的操作方法(c代表容器)：c.size();   //返回容器中元素的个数   c.empty();   //判断容器是否为空

使用场景：
Vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。
deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。
vector与deque的比较：
一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置却是不固定的。
二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。
三：deque支持头部的快速插入与快速移除，这是deque的优点。
list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。
set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 
map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。